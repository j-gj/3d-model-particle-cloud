<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Wireframe 3D Viewer</title>
    <script type="module">
        import { GLTFExporter } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/exporters/GLTFExporter.js';
        window.THREE = window.THREE || {};
        window.THREE.GLTFExporter = GLTFExporter;
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: #1a1a1a;
            color: white;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 20px;
            width: 300px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 1000;
            max-height: 95vh;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 40px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        .control-group input[type="number"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #444;
            border-radius: 5px;
            background: #2a2a2a;
            color: white;
        }

        #upload-area {
            border: 2px dashed #666;
            border-radius: 10px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 20px;
        }

        #upload-area:hover {
            border-color: #888;
            background: rgba(255, 255, 255, 0.05);
        }

        #upload-area.dragover {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }

        #file-input {
            display: none;
        }

        .button {
            background: #333;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
            transition: background 0.3s ease;
        }

        .button:hover {
            background: #555;
        }

        .button:disabled {
            background: #222;
            cursor: not-allowed;
            opacity: 0.5;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 40px;
            border-radius: 10px;
            display: none;
            z-index: 2000;
        }

        .preset-colors {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .color-preset {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid #666;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-preset:hover {
            transform: scale(1.1);
            border-color: #fff;
        }

        #model-info {
            font-size: 12px;
            color: #aaa;
            margin-top: 10px;
        }

        .info-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="canvas-container"></div>

        <div id="controls">
            <h2>Particle Wireframe Viewer</h2>

            <div id="upload-area">
                <p>üìÅ Drag & Drop 3D Model</p>
                <p>or click to browse</p>
                <p class="info-text">Supports: GLB, GLTF, OBJ, FBX</p>
                <input type="file" id="file-input" accept=".glb,.gltf,.obj,.fbx" />
            </div>

            <div class="control-group">
                <label>Particle Count: <span id="particle-count">5000</span> / <span
                        id="particle-max-count">50000</span></label>
                <input type="range" id="particle-density" min="1000" max="50000" value="5000" step="500">
                <div class="info-text">Higher values may impact performance</div>
            </div>

            <div class="control-group">
                <label>Particle Size: <span id="particle-size-value">0.1</span></label>
                <input type="range" id="particle-size" min="0.1" max="20" value="0.1" step="0.1">
            </div>

            <div class="control-group">
                <label>Particle Color</label>
                <div class="preset-colors">
                    <div class="color-preset" style="background: #372CD5" data-color="#372CD5"></div>
                    <div class="color-preset" style="background: #637AFF" data-color="#637AFF"></div>
                    <div class="color-preset" style="background: #050033" data-color="#050033"></div>
                    <div class="color-preset" style="background: #F0F4FF" data-color="#F0F4FF"></div>
                    <div class="color-preset" style="background: #9FADED" data-color="#9FADED"></div>
                </div>
                <input type="color" id="particle-color" value="#372CD5">
            </div>

            <div class="control-group">
                <label>Background Color</label>
                <div class="preset-colors">
                    <div class="color-preset" style="background: #000000" data-color="#000000"></div>
                    <div class="color-preset" style="background: #ffffff" data-color="#ffffff"></div>
                    <div class="color-preset" style="background: #F0F4FF" data-color="#F0F4FF"></div>
                    <div class="color-preset" style="background: #637AFF" data-color="#637AFF"></div>
                    <div class="color-preset" style="background: #9FADED" data-color="#9FADED"></div>
                </div>
                <input type="color" id="background-color" value="#ffffff">
            </div>

            <!-- New Camera Controls -->
            <div class="control-group">
                <h3>Camera Controls</h3>

                <label>Zoom In Limit (minDistance): <span id="min-distance-value">0.1</span></label>
                <input type="range" id="min-distance-slider" min="0.01" max="10" value="0.1" step="0.01">

                <label>Zoom Out Limit (maxDistance): <span id="max-distance-value">5000</span></label>
                <input type="range" id="max-distance-slider" min="10" max="5000" value="5000" step="10">

                <label>Field of View (FOV): <span id="fov-value">75</span></label>
                <input type="range" id="fov-slider" min="10" max="120" value="75" step="1">

                <label>Near Clip Plane: <span id="near-value">0.1</span></label>
                <input type="range" id="near-slider" min="0.01" max="100" value="0.1" step="0.01">

                <label>Far Clip Plane: <span id="far-value">8000</span></label>
                <input type="range" id="far-slider" min="10" max="10000" value="8000" step="10">
            </div>
            <!-- End of New Camera Controls -->

            <div class="control-group">
                <button class="button" id="reset-camera">Reset Camera</button>
                <button class="button" id="center-object">Center Object</button>
                <button class="button" id="export-screenshot">Export Screenshot</button>
                <button class="button" id="export-point-cloud">Export Point Cloud (JSON)</button>
                <button class="button" id="export-glb">Export Point Cloud (GLB)</button>
            </div>

            <div id="model-info"></div>
        </div>

        <div id="loading">
            <p>Processing 3D model...</p>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';

        class ParticleWireframeViewer {
            constructor() {
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
                this.controls = null;
                this.particles = null;
                this.currentModel = null;
                this.surfaceTriangles = []; // Changed from surfacePoints
                this.modelMaxSize = 1;
                this.particleTexture = this.createParticleTexture();

                this.settings = {
                    particleCount: 25000,
                    particleSize: 0.1,
                    particleColor: '#372CD5',
                    backgroundColor: '#fff',
                    cameraFov: 75,
                    cameraNear: 0.1,
                    cameraFar: 7000,
                    cameraMinDistance: 0.1,
                    cameraMaxDistance: 1000
                };

                this.init();
                this.setupEventListeners();
            }

            init() {
                // Setup renderer
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(new THREE.Color(this.settings.backgroundColor));
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                // Setup camera
                this.camera.fov = this.settings.cameraFov;
                this.camera.near = this.settings.cameraNear;
                this.camera.far = this.settings.cameraFar;
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                this.camera.updateProjectionMatrix();

                // Setup orbit controls
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = true;
                this.controls.minDistance = this.settings.cameraMinDistance;
                this.controls.maxDistance = this.settings.cameraMaxDistance;
                this.controls.update();

                // Setup lighting (minimal for wireframe effect)
                const ambientLight = new THREE.AmbientLight(0x404040, 0.1);
                this.scene.add(ambientLight);

                // Start render loop
                this.animate();
            }

            setupEventListeners() {
                // File upload
                const uploadArea = document.getElementById('upload-area');
                const fileInput = document.getElementById('file-input');

                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.loadModel(files[0]);
                    }
                });

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.loadModel(e.target.files[0]);
                    }
                });

                // Controls
                document.getElementById('particle-density').addEventListener('input', (e) => {
                    this.settings.particleCount = parseInt(e.target.value);
                    document.getElementById('particle-count').textContent = this.settings.particleCount.toLocaleString();
                    this.updateParticles();
                });

                document.getElementById('particle-size').addEventListener('input', (e) => {
                    this.settings.particleSize = parseFloat(e.target.value);
                    document.getElementById('particle-size-value').textContent = this.settings.particleSize;
                    this.updateParticleSize();
                });

                document.getElementById('particle-color').addEventListener('input', (e) => {
                    this.settings.particleColor = e.target.value;
                    this.updateParticleColor();
                });

                document.getElementById('background-color').addEventListener('input', (e) => {
                    this.settings.backgroundColor = e.target.value;
                    this.renderer.setClearColor(new THREE.Color(this.settings.backgroundColor));
                });

                // New camera control event listeners
                document.getElementById('min-distance-slider').addEventListener('input', (e) => {
                    this.settings.cameraMinDistance = parseFloat(e.target.value);
                    document.getElementById('min-distance-value').textContent = this.settings.cameraMinDistance;
                    this.controls.minDistance = this.settings.cameraMinDistance;
                    this.controls.update();
                });
                document.getElementById('max-distance-slider').addEventListener('input', (e) => {
                    this.settings.cameraMaxDistance = parseFloat(e.target.value);
                    document.getElementById('max-distance-value').textContent = this.settings.cameraMaxDistance;
                    this.controls.maxDistance = this.settings.cameraMaxDistance;
                    this.controls.update();
                });
                document.getElementById('fov-slider').addEventListener('input', (e) => {
                    this.settings.cameraFov = parseFloat(e.target.value);
                    document.getElementById('fov-value').textContent = this.settings.cameraFov;
                    this.camera.fov = this.settings.cameraFov;
                    this.camera.updateProjectionMatrix();
                });
                document.getElementById('near-slider').addEventListener('input', (e) => {
                    this.settings.cameraNear = parseFloat(e.target.value);
                    document.getElementById('near-value').textContent = this.settings.cameraNear;
                    this.camera.near = this.settings.cameraNear;
                    this.camera.updateProjectionMatrix();
                });
                document.getElementById('far-slider').addEventListener('input', (e) => {
                    this.settings.cameraFar = parseFloat(e.target.value);
                    document.getElementById('far-value').textContent = this.settings.cameraFar;
                    this.camera.far = this.settings.cameraFar;
                    this.camera.updateProjectionMatrix();
                });


                // Color presets
                document.querySelectorAll('.color-preset').forEach(preset => {
                    preset.addEventListener('click', (e) => {
                        const color = e.target.dataset.color;
                        const parentGroup = e.target.closest('.control-group');
                        const colorInput = parentGroup.querySelector('input[type="color"]');

                        if (colorInput) {
                            colorInput.value = color;
                            colorInput.dispatchEvent(new Event('input'));
                        }
                    });
                });

                // Buttons
                document.getElementById('reset-camera').addEventListener('click', () => {
                    this.resetCamera();
                });

                document.getElementById('center-object').addEventListener('click', () => {
                    this.centerObject();
                });

                document.getElementById('export-screenshot').addEventListener('click', () => {
                    this.exportScreenshot();
                });

                document.getElementById('export-point-cloud').addEventListener('click', () => {
                    this.exportPointCloud();
                });

                document.getElementById('export-glb').addEventListener('click', () => {
                    this.exportGLB();
                });

                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            // New function to create a circular particle texture
            createParticleTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const context = canvas.getContext('2d');
                context.beginPath();
                context.arc(32, 32, 32, 0, 2 * Math.PI, false);
                context.fillStyle = 'white';
                context.fill();

                return new THREE.CanvasTexture(canvas);
            }

            loadModel(file) {
                const loading = document.getElementById('loading');
                loading.style.display = 'block';

                const reader = new FileReader();
                reader.onload = (e) => {
                    const arrayBuffer = e.target.result;
                    const extension = file.name.split('.').pop().toLowerCase();

                    try {
                        switch (extension) {
                            case 'glb':
                            case 'gltf':
                                this.loadGLTF(arrayBuffer);
                                break;
                            case 'obj':
                                this.loadOBJ(e.target.result);
                                break;
                            case 'fbx':
                                this.loadFBX(arrayBuffer);
                                break;
                            default:
                                throw new Error('Unsupported file format');
                        }
                    } catch (error) {
                        console.error('Error loading model:', error);
                        // Using a simple modal-like alert instead of the native one
                        this.showInfoMessage('Error loading model: ' + error.message, true);
                        loading.style.display = 'none';
                    }
                };

                // Read as array buffer for gltf/glb/fbx and as text for obj
                const extension = file.name.split('.').pop().toLowerCase();
                if (extension === 'obj') {
                    reader.readAsText(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            }

            loadGLTF(arrayBuffer) {
                const loader = new GLTFLoader();
                loader.parse(arrayBuffer, '', (gltf) => {
                    this.processModel(gltf.scene);
                }, (error) => {
                    console.error('GLTF loading error:', error);
                    this.showInfoMessage('Error loading GLTF file: ' + error.message, true);
                    document.getElementById('loading').style.display = 'none';
                });
            }

            loadOBJ(text) {
                try {
                    const loader = new OBJLoader();
                    const object = loader.parse(text);
                    this.processModel(object);
                } catch (error) {
                    console.error('OBJ loading error:', error);
                    this.showInfoMessage('Error loading OBJ file: ' + error.message, true);
                    document.getElementById('loading').style.display = 'none';
                }
            }

            loadFBX(arrayBuffer) {
                try {
                    const loader = new FBXLoader();
                    const object = loader.parse(arrayBuffer);
                    this.processModel(object);
                } catch (error) {
                    console.error('FBX loading error:', error);
                    this.showInfoMessage('Error loading FBX file: ' + error.message, true);
                    document.getElementById('loading').style.display = 'none';
                }
            }

            processModel(model) {
                // Clear existing model
                if (this.currentModel) {
                    this.scene.remove(this.currentModel);
                }
                if (this.particles) {
                    this.scene.remove(this.particles);
                }

                // Center the new model at the scene origin (0,0,0)
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                model.position.sub(center);

                this.currentModel = model;

                // Extract geometry and sample surface points (back to original method)
                this.surfacePoints = this.extractSurfacePoints(model);

                // Dynamically update particle density slider based on the model's surface points
                const particleDensitySlider = document.getElementById('particle-density');
                const particleMaxCountSpan = document.getElementById('particle-max-count');
                const maxPoints = this.surfacePoints.length;

                particleDensitySlider.max = maxPoints;
                particleMaxCountSpan.textContent = maxPoints.toLocaleString();

                // Ensure the current particle count is not higher than the new max
                this.settings.particleCount = Math.min(this.settings.particleCount, maxPoints);
                particleDensitySlider.value = this.settings.particleCount;
                document.getElementById('particle-count').textContent = this.settings.particleCount.toLocaleString();

                // Calculate the max size of the new model
                const size = box.getSize(new THREE.Vector3());
                this.modelMaxSize = Math.max(size.x, size.y, size.z);

                // Create particle system
                this.createParticleSystem();

                // Update model info
                this.updateModelInfo();

                // Reset the camera and fit to the new model
                this.resetCamera();

                document.getElementById('loading').style.display = 'none';
            }

            // BACK TO ORIGINAL: Extract surface points with better sampling
            extractSurfacePoints(object) {
                const points = [];

                object.traverse((child) => {
                    if (child.isMesh && child.geometry) {
                        const geometry = child.geometry;
                        const positions = geometry.attributes.position;
                        const matrix = child.matrixWorld;

                        if (geometry.index) {
                            // Indexed geometry
                            const indices = geometry.index.array;
                            for (let i = 0; i < indices.length; i += 3) {
                                const a = indices[i];
                                const b = indices[i + 1];
                                const c = indices[i + 2];

                                // Increased samples per triangle for better coverage
                                this.sampleTriangle(positions, a, b, c, matrix, points, 15);
                            }
                        } else {
                            // Non-indexed geometry
                            for (let i = 0; i < positions.count; i += 3) {
                                const a = i;
                                const b = i + 1;
                                const c = i + 2;

                                this.sampleTriangle(positions, a, b, c, matrix, points, 15);
                            }
                        }
                    }
                });

                return points;
            }

            sampleTriangle(positions, a, b, c, matrix, points, samples) {
                const v1 = new THREE.Vector3().fromBufferAttribute(positions, a);
                const v2 = new THREE.Vector3().fromBufferAttribute(positions, b);
                const v3 = new THREE.Vector3().fromBufferAttribute(positions, c);

                // Transform vertices to world space
                v1.applyMatrix4(matrix);
                v2.applyMatrix4(matrix);
                v3.applyMatrix4(matrix);

                // Sample points on triangle surface using barycentric coordinates
                for (let i = 0; i < samples; i++) {
                    const r1 = Math.random();
                    const r2 = Math.random();

                    const u = 1 - Math.sqrt(r1);
                    const v = Math.sqrt(r1) * (1 - r2);
                    const w = Math.sqrt(r1) * r2;

                    const point = new THREE.Vector3()
                        .addScaledVector(v1, u)
                        .addScaledVector(v2, v)
                        .addScaledVector(v3, w);

                    points.push(point);
                }
            }

            // IMPROVED: Better sampling with shuffled selection
            createParticleSystem() {
                if (this.surfacePoints.length === 0) return;

                // Create shuffled indices to ensure better distribution
                const indices = Array.from({ length: this.surfacePoints.length }, (_, i) => i);

                // Fisher-Yates shuffle for random but complete coverage
                for (let i = indices.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [indices[i], indices[j]] = [indices[j], indices[i]];
                }

                // Select points using shuffled indices for better distribution
                const selectedPoints = [];
                const step = Math.max(1, Math.floor(this.surfacePoints.length / this.settings.particleCount));

                // Take every 'step' points from shuffled array, plus some random extras
                for (let i = 0; i < indices.length && selectedPoints.length < this.settings.particleCount; i += step) {
                    selectedPoints.push(this.surfacePoints[indices[i]]);
                }

                // If we still need more points, fill randomly from remaining
                while (selectedPoints.length < this.settings.particleCount && selectedPoints.length < this.surfacePoints.length) {
                    const randomIndex = Math.floor(Math.random() * this.surfacePoints.length);
                    selectedPoints.push(this.surfacePoints[randomIndex]);
                }

                // Create geometry
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(selectedPoints.length * 3);

                for (let i = 0; i < selectedPoints.length; i++) {
                    positions[i * 3] = selectedPoints[i].x;
                    positions[i * 3 + 1] = selectedPoints[i].y;
                    positions[i * 3 + 2] = selectedPoints[i].z;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Calculate relative particle size based on model scale
                const relativeSize = this.settings.particleSize * (this.modelMaxSize / 100);

                // Create material with the circular texture
                const material = new THREE.PointsMaterial({
                    color: new THREE.Color(this.settings.particleColor),
                    size: relativeSize,
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.8,
                    map: this.particleTexture,
                    alphaTest: 0.5
                });

                // Create particles
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);
            }

            updateParticles() {
                if (this.surfacePoints.length > 0) {
                    if (this.particles) {
                        this.scene.remove(this.particles);
                    }
                    this.createParticleSystem();
                }
            }

            updateParticleColor() {
                if (this.particles) {
                    this.particles.material.color.set(this.settings.particleColor);
                }
            }

            updateParticleSize() {
                if (this.particles) {
                    const newSize = this.settings.particleSize * (this.modelMaxSize / 100);
                    this.particles.material.size = newSize;
                }
            }

            updateModelInfo() {
                const info = document.getElementById('model-info');
                info.innerHTML = `
                    <strong>Model Loaded</strong><br>
                    Model Size: ${(this.modelMaxSize).toFixed(2)} units<br>
                    Surface Points: ${this.surfacePoints.length.toLocaleString()}<br>
                    Active Particles: ${Math.min(this.settings.particleCount, this.surfacePoints.length).toLocaleString()}
                `;
            }

            fitCameraToModel() {
                if (!this.currentModel) return;

                const box = new THREE.Box3().setFromObject(this.currentModel);
                const size = box.getSize(new THREE.Vector3());

                const maxSize = Math.max(size.x, size.y, size.z);
                const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * this.camera.fov / 360));
                const fitWidthDistance = fitHeightDistance / this.camera.aspect;
                const distance = 1.2 * Math.max(fitHeightDistance, fitWidthDistance);

                const direction = this.camera.position.clone().sub(this.controls.target).normalize().multiplyScalar(distance);
                this.camera.position.copy(this.controls.target).add(direction);

                if (this.controls) {
                    this.controls.update();
                }
            }

            centerObject() {
                if (!this.controls) return;

                // Get current camera position relative to current target
                const currentDistance = this.controls.target.distanceTo(this.camera.position);
                const currentDirection = this.camera.position.clone().sub(this.controls.target).normalize();

                // Set target back to origin (0, 0, 0)
                this.controls.target.set(0, 0, 0);

                // Reposition camera to maintain same distance and angle, but now relative to origin
                const newCameraPosition = new THREE.Vector3()
                    .copy(currentDirection)
                    .multiplyScalar(currentDistance)
                    .add(this.controls.target);

                this.camera.position.copy(newCameraPosition);
                this.camera.lookAt(this.controls.target);

                // Update controls
                this.controls.update();

                console.log('Object centered - camera distance and angle preserved');
            }

            resetCamera() {
                this.camera.fov = this.settings.cameraFov;
                this.camera.near = this.settings.cameraNear;
                this.camera.far = this.settings.cameraFar;
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                this.camera.updateProjectionMatrix();

                if (this.controls) {
                    this.controls.minDistance = this.settings.cameraMinDistance;
                    this.controls.maxDistance = this.settings.cameraMaxDistance;
                    this.controls.target.set(0, 0, 0);
                    this.controls.update();
                }

                if (this.currentModel) {
                    this.fitCameraToModel();
                }
            }

            exportScreenshot() {
                const link = document.createElement('a');
                link.download = 'particle-wireframe.png';
                link.href = this.renderer.domElement.toDataURL('image/png');
                link.click();
            }

            exportPointCloud() {
                if (!this.particles) {
                    this.showInfoMessage('No particle system loaded to export!', true);
                    return;
                }

                // Show loading message
                this.showInfoMessage('Preparing point cloud export...', false);

                // Get particle positions
                const positions = this.particles.geometry.attributes.position.array;
                const particleCount = positions.length / 3;

                // Capture current camera state
                const cameraDistance = this.controls.target.distanceTo(this.camera.position);
                const cameraTarget = this.controls.target.clone();

                // Calculate spherical coordinates for the camera position relative to target
                const cameraDirection = this.camera.position.clone().sub(cameraTarget).normalize();
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(cameraDirection);

                // Quantization settings - adjust precision as needed
                const precision = 1000; // 3 decimal places (0.001 unit precision)
                const quantizedCloud = [];

                // Convert to quantized coordinates
                for (let i = 0; i < positions.length; i += 3) {
                    const x = Math.round(positions[i] * precision);
                    const y = Math.round(positions[i + 1] * precision);
                    const z = Math.round(positions[i + 2] * precision);
                    quantizedCloud.push([x, y, z]);
                }

                // Create metadata with camera information
                const exportData = {
                    metadata: {
                        version: "1.1",
                        particleCount: particleCount,
                        quantizationFactor: precision,
                        originalModelSize: this.modelMaxSize,
                        exportDate: new Date().toISOString(),
                        camera: {
                            distance: cameraDistance,
                            target: {
                                x: cameraTarget.x,
                                y: cameraTarget.y,
                                z: cameraTarget.z
                            },
                            spherical: {
                                radius: spherical.radius,
                                phi: spherical.phi,      // vertical angle
                                theta: spherical.theta   // horizontal angle (rotation)
                            },
                            fov: this.camera.fov,
                            near: this.camera.near,
                            far: this.camera.far
                        },
                        note: "Divide coordinates by quantizationFactor to get original values"
                    },
                    particles: quantizedCloud
                };

                // Convert to JSON string
                const jsonString = JSON.stringify(exportData);

                // Calculate file sizes for user info
                const originalSize = positions.length * 4; // Float32 = 4 bytes each
                const jsonSize = new Blob([jsonString]).size;
                const compressionRatio = ((originalSize - jsonSize) / originalSize * 100).toFixed(1);

                // Create and download file
                const dataBlob = new Blob([jsonString], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(dataBlob);
                link.download = `particle-cloud-${particleCount}pts.json`;
                link.click();

                // Show success message with stats
                setTimeout(() => {
                    this.showInfoMessage(
                        `Point cloud exported! ${particleCount.toLocaleString()} particles, ` +
                        `${(jsonSize / 1024 / 1024).toFixed(2)}MB (${compressionRatio}% compression)`,
                        false
                    );
                }, 100);
            }

            exportGLB() {
                if (!this.particles) {
                    this.showInfoMessage('No particle system loaded to export!', true);
                    return;
                }

                // Check if GLTFExporter is available
                if (typeof window.THREE.GLTFExporter === 'undefined') {
                    this.showInfoMessage(
                        'GLB export requires GLTFExporter. Please add GLTFExporter script to enable this feature.',
                        true
                    );
                    return;
                }

                // Show loading message
                this.showInfoMessage('Preparing GLB export...', false);

                // Capture current camera state (same as JSON export)
                const cameraDistance = this.controls.target.distanceTo(this.camera.position);
                const cameraTarget = this.controls.target.clone();
                const cameraDirection = this.camera.position.clone().sub(cameraTarget).normalize();
                const spherical = new THREE.Spherical();
                spherical.setFromVector3(cameraDirection);

                // Create a scene specifically for export
                const exportScene = new THREE.Scene();

                // Clone the particle system for export
                const exportGeometry = this.particles.geometry.clone();
                const exportMaterial = this.particles.material.clone();
                const exportParticles = new THREE.Points(exportGeometry, exportMaterial);

                // Add metadata as userData (GLB supports custom data)
                exportParticles.userData = {
                    particleViewer: {
                        version: "1.1",
                        particleCount: this.particles.geometry.attributes.position.count,
                        originalModelSize: this.modelMaxSize,
                        exportDate: new Date().toISOString(),
                        camera: {
                            distance: cameraDistance,
                            target: {
                                x: cameraTarget.x,
                                y: cameraTarget.y,
                                z: cameraTarget.z
                            },
                            spherical: {
                                radius: spherical.radius,
                                phi: spherical.phi,
                                theta: spherical.theta
                            },
                            fov: this.camera.fov,
                            near: this.camera.near,
                            far: this.camera.far
                        },
                        particleSettings: {
                            color: this.settings.particleColor,
                            size: this.settings.particleSize
                        }
                    }
                };

                exportScene.add(exportParticles);

                // Configure GLTFExporter
                const exporter = new window.THREE.GLTFExporter();
                const options = {
                    binary: true, // Export as GLB (binary format)
                    includeCustomExtensions: true,
                    maxTextureSize: 4096
                };

                // Export to GLB
                exporter.parse(
                    exportScene,
                    (gltfData) => {
                        // gltfData is an ArrayBuffer for GLB format
                        const blob = new Blob([gltfData], { type: 'model/gltf-binary' });
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(blob);
                        link.download = `particle-cloud-${exportParticles.userData.particleViewer.particleCount}pts.glb`;
                        link.click();

                        // Show success message with file size
                        const fileSizeMB = (blob.size / 1024 / 1024).toFixed(2);
                        setTimeout(() => {
                            this.showInfoMessage(
                                `GLB exported! ${exportParticles.userData.particleViewer.particleCount.toLocaleString()} particles, ` +
                                `${fileSizeMB}MB - optimized for fast loading!`,
                                false
                            );
                        }, 100);
                    },
                    (error) => {
                        console.error('GLB export error:', error);
                        this.showInfoMessage('Error during GLB export: ' + error.message, true);
                    },
                    options
                );
            }

            // Helper function to load point cloud back into Three.js (for reference)
            loadPointCloudFromJSON(jsonData) {
                const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                const particles = data.particles;
                const quantizationFactor = data.metadata.quantizationFactor;

                const positions = new Float32Array(particles.length * 3);

                particles.forEach((point, i) => {
                    positions[i * 3] = point[0] / quantizationFactor;
                    positions[i * 3 + 1] = point[1] / quantizationFactor;
                    positions[i * 3 + 2] = point[2] / quantizationFactor;
                });

                const geometry = new THREE.BufferGeometry();
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Use your existing material settings
                const material = new THREE.PointsMaterial({
                    color: new THREE.Color(this.settings.particleColor),
                    size: this.settings.particleSize * (data.metadata.originalModelSize / 100),
                    sizeAttenuation: true,
                    transparent: true,
                    opacity: 0.8,
                    map: this.particleTexture,
                    alphaTest: 0.5
                });

                return new THREE.Points(geometry, material);
            }

            // Custom function to display a message instead of native alert()
            showInfoMessage(message, isError = false) {
                const loadingDiv = document.getElementById('loading');
                const pTag = loadingDiv.querySelector('p');
                pTag.textContent = message;
                loadingDiv.style.display = 'block';
                if (isError) {
                    loadingDiv.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
                    setTimeout(() => {
                        loadingDiv.style.display = 'none';
                        loadingDiv.style.backgroundColor = 'rgba(0, 0, 0, 0.9)';
                        pTag.textContent = 'Processing 3D model...';
                    }, 5000);
                } else {
                    setTimeout(() => {
                        loadingDiv.style.display = 'none';
                        pTag.textContent = 'Processing 3D model...';
                    }, 2000);
                }
            }

            animate() {
                requestAnimationFrame(() => this.animate());

                if (this.controls) {
                    this.controls.update();
                }

                this.renderer.render(this.scene, this.camera);
            }
        }

        // Wait for the window to load before initializing the app
        window.onload = function () {
            new ParticleWireframeViewer();
        }
    </script>
</body>

</html>